有这么一个段子...
>老杨一推代码， 所有的开发同事便都看着他笑， 有的叫道，“ 老杨， 你又把代码合丢了！” 他不回答， 对产品说，“ 追加两个需求, 只做性能优化。” 便排出一台MacBook Pro。 他们又故意的高声嚷道，“ 你推错分支了！” 老杨睁大眼睛说，“ 你怎么这样凭空污人清白……”，“ 什么清白？ 我前天亲眼见你写Bug把流水线搞挂， 又改崩生产代码“。 老杨便涨红了脸， 额上的青筋条条绽出， 争辩道，“ 流水线报错不算错， 合代码挂掉的事能叫Bug吗？” 接连便是难懂的话， 什么“ Merge大法好, GitFlow卍解”， 什么“ 拉代码不需要Rebase” 之类， 引得众人都哄笑起来： 店内外充满了快活的空气。
>
**用git的， 谁没合丢过代码呢？**（ 反正我是合丢过。。。）

好， 痛定思痛， 我决定从原理上理解Git， 所以决定写下这篇文章（ 才不会说是因为buddy叫我准备一场针对Git的session）.
PS： 这篇文章不会是一个体系完善的Git教程， 而是会针对性地从原理上理解一些我们常用的Git命令， 最终目标就是能够在多人合作的场景下保证所有分支的代码安全。

# 目录
- [目录](#目录)
- [Git的那些概念](#git的那些概念)
  - [Git的本质是什么 ?](#git的本质是什么-)
  - [几个重要的概念（类比字典）](#几个重要的概念类比字典)
- [Git的那些操作（只是我们会经常用到的常用操作:)）](#git的那些操作只是我们会经常用到的常用操作)
- [Git的那些冲突（针对TrunkFlow）](#git的那些冲突针对trunkflow)
  - [出现冲突的可能情形](#出现冲突的可能情形)
  - [规避冲突的优选操作](#规避冲突的优选操作)
  - [解决冲突的原则](#解决冲突的原则)
  - [解决冲突的优选流程](#解决冲突的优选流程)
  - [其他的奇技淫巧](#其他的奇技淫巧)
    - [别名](#别名)

# Git的那些概念
## Git的本质是什么 ?
Git的本质其实是~~复读机~~一个**内容寻址（content-addressable）文件系统**，并在此之上提供了一个版本控制系统的用户界面。Git的核心部分是一个简单的**键值对数据库**。 你可以向该数据库**插入任意类型的值（object）**，它会**返回一个键值（object的引用地址，SHA-1字符串）**，通过该键值可以在任意时刻再次检索该内容，因此我们引出了如下的
## 几个重要的概念（类比字典）
- object：字典项（有实际内容）
  - blob：对应的值是特定文件的特定版本的内容（不包括文件名）。

    ![blob](http://my.csdn.net/uploads/201206/19/1340112751_1500.jpg)
  - tree：对应的值的内含信息是一个或多个字典项的数据列表，这些被指向项上存放内容可以是文件（`blob`）的包裹体，也可以是文件夹（`tree`）的包裹体，这些包裹体会附带文件（夹）的名称等元数据。
    
    ![tree](http://my.csdn.net/uploads/201206/19/1340112774_4979.jpg)

  - commit：对应的值的是一个包括父级`commit`的地址、作者信息以及提交message等信息的数据集（`Comments`），以及一些代表变更后文件的`tree`。
    
    ![commit](http://my.csdn.net/uploads/201206/19/1340112824_8482.jpg)

    以Git GUI里面的一个提交为例，可以看得更加清楚

    ![image](https://user-images.githubusercontent.com/11873100/50170232-5de04780-032a-11e9-9100-3ce2f3ceba7b.png)（红色框部分为`Comments`数据集，蓝色框部分为指向一个文件的`tree`）

  - tag：对应的值是一个包括一个地址（99.999%的情形是`commit`的地址，其他情况不讨论）、一个标签创建者信息、一个日期、一段注释信息的数据集。
    
    ![tag](https://camo.githubusercontent.com/dc9c255b9b57cae2d0b4c99480dca5af2d24ba37/687474703a2f2f6d792e6373646e2e6e65742f75706c6f6164732f3230313230362f31392f313334303131323838315f333739352e6a7067)

所以最终的整体结构应该是这样：

![objects](https://git-scm.com/book/en/v2/images/data-model-3.png)

PS：
1. 我们所使用的日常git命令基本都是在操作commit和tag
2. 理解原理，只有两类对象，值有意义（值是数据本身）的对象&值没有意义（值是引用）的对象

- ref：指向字典键的引用（没有实际内容，只是SHA-1的别名）
  - branch：指向某一系列提交之首的引用，它是一个可以移动的`tag`
  - HEAD：指向目前所在的分支的引用
  - tag：
    - lightweight tag：指向任意提交的引用
    - annotated tag：指向一个标签对象的引用
  - remote branch：指向某服务器端某一系列提交之首的引用

# Git的那些操作（只是我们会经常用到的常用操作:)）

- file-level
  - stage @path：标记文件需要被提交
  - reset @path：取消文件的stage状态
    - --hard：取消文件的stage状态并恢复其到unmodified状态
  - checkout @path: 等价于reset @path --hard
- commit-level
  - commit：提交<!-- -m "message"来附加提交信息 -->
    - --amend：与前一个提交合并提交（改写）
  - reset @commitid=null：重置HEAD到指定commit上<!-- commitid为null时其实操作只是重置了HEAD -->
    - --hard：抛弃reset过程中的所有文件变更
  - checkout @commitid=null：转移HEAD到指定commit上<!-- commitid为null时等价于reset --hard -->
  - revert @commitid：提交一次与某次提交的内容完全相反的提交<!-- 历史依然单向移动 -->
  ![reset vs checkout](https://user-images.githubusercontent.com/11873100/50234698-3902d780-03f1-11e9-9b6b-28088db3b7a6.png)
  - tag：标记具有某种特殊意义的提交（里程碑）
  - branch：创建一个分支<!-- 实际上是给一个commit打上分支的标记 -->
  - push：将本地的commit推送到服务器（默认不会推送tag）<!-- 需要保证此时代码为最新版本 -->
    - push --tag：连tag一起推送<!-- force 这些操作就不提了，因为理论来说不应该使用它们 -->

PS：注意，上面的所有commitid都可以换成对应的ref，比如branch、tag

# Git的那些冲突（针对TrunkFlow）

## 出现冲突的可能情形

- 他人和自己编辑了对同一文件的编辑内容存在交叉行<!-- 最简单, 借助diff工具可以直接解决 -->
  <!-- 后面两种会比较麻烦, 后面解决冲突部分详细说明 -->
- 他人删除、移动了自己编辑的文件
- 他人和自己新增了同名的文件

## 规避冲突的优选操作

- 小步提交 <!-- 增加上传频率, 小伙伴们更容易获取到最新的代码 -->
- 勤获取代码（*Build前自动获取最新代码*）<!-- 增加下载频率, 更容易获取到最新的代码 -->

## 解决冲突的原则

- 确保现有代码安全
- 叠加新增修改
- 不盲目操作

Then

## 解决冲突的优选流程

1. 使用他人的代码(use theirs)
2. 叠加自己的改动
3. 遇到一时无法解决的问题，和原有代码作者pair解决
4. 找不到原有代码作者时可以暂时abort

PS：针对树冲突（上面可能出现的冲突的后两种）的处理流程（个人总结，有更好的办法请务必告诉我）
1. abort本次rebase
2. 重命名备份冲突文件并amend commit
3. pull&rebase
4. 借助第三方比较工具，将自己的改动覆盖在被移动了位置的原文件上
5. 再次amend commit

## 其他的奇技淫巧

### 别名

```bash
git config --global alias.co checkout
```